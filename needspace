#!/usr/bin/env perl
# Search candidates for removal to free some disk space.
# Taken from "The Otter Book" by David N. Blank-Edelman and modified.
use strict;
use warnings;

use File::Find;
use File::Basename;

my %derivations = (
    '.dvi' => '.tex',
    '.aux' => '.tex',
    '.toc' => '.tex',
    '.o'   => '.c',
);

my %types = (
    'bak'  => 'backup files',
    'tex'  => 'files that can be recreated by running La/TeX',
    'doto' => 'files that can be recreated by recompiling source',
    'git'  => 'git repositories',
);

my $targets;     # we'll collect the files we find into this HoH
my %baseseen;    # for caching base files

my $homedir = ( getpwuid($<) )[7];    # find the user's home dir

chdir $homedir or die "Unable to change to your homedir $homedir:$!\n";

$|++;                                 # don't buffer printing to STDOUT

print 'Scanning';
find( \&wanted, '.' );
print "done.\n";

sub wanted {

    # print a dot for every dir so the use knows we're doing something
    print '.' if -d $_;

    # check for git repositories
    if ( -d $_ && /^\.git$/ ) {
        my $dir = dirname($File::Find::name);
        $dir =~ s|^\./|~/|;
        my $size = ( split /\s+/, `du -s $dir` )[0] * 1024; # we work with bytes
        $targets->{git}{$dir} = $size;
        return;
    }

    # from now on we look only for files
    return unless -f $_;

    # check for core files
    $_ eq 'core'
      && ( $targets->{core}{$File::Find::name} = ( stat(_) )[7] )
      && return;

    # check for backup and autosave files
    (/~$/)
      && ( $targets->{bak}{$File::Find::name} = ( stat(_) )[7] )
      && return;

    # check for derivable .o files
    /\.o$/
      && BaseFileExists($File::Find::name)
      && ( $targets->{doto}{$File::Find::name} = ( stat(_) )[7] )
      && return;
}

foreach my $kind ( sort keys %types ) {
    ReportDerivFiles( $kind, $types{$kind} );
}

sub ReportDerivFiles {
    my $kind     = shift;    # kind of file we're reporting on
    my $message  = shift;    # a message so we can describe it
    my $tempsize = 0;

    return unless exists $targets->{$kind};

    print "\nThe following are most likely $message:\n";

    foreach my $path ( keys %{ $targets->{$kind} } ) {
        $tempsize += $targets->{$kind}{$path};
        ( my $prettypath = $path ) =~ s|\./|~/|;    # make path prettier
        print "$prettypath ($targets->{$kind}{$path} bytes)\n";
    }
    print 'These files take up ' . BytesToMeg($tempsize) . "MB total.\n\n";
}

sub BytesToMeg {                                    # convert bytes to X.XXMB
    my $size = shift;
    return sprintf "%.2f", $size / ( 1024 * 1024 );
}
